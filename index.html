<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Combined Isochrone Map for Leisure Facilities</title>
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.9.0/mapbox-gl.js"></script>
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.9.0/mapbox-gl.css" rel="stylesheet" />
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <style>
        body { margin: 0; padding: 0; }
        #map { height: 100vh; width: 100%; }
        .legend {
            position: absolute;
            bottom: 30px;
            left: 10px;
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            z-index: 1000;
        }
        .legend div { margin-bottom: 5px; }
        .legend-color {
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-right: 5px;
            vertical-align: middle;
        }
        .mapboxgl-ctrl-group { margin: 10px; }
    </style>
</head>
<body>
    <div id="map"></div>
    <script>
        mapboxgl.accessToken = 'pk.eyJ1IjoibmV3aXNsYW5kMTIyMyIsImEiOiJjamJqaG5jb3Y0MHVpMnFxZ3IzN3NhbGwzIn0.giv88MrlUsX2WznylrLvwA';

        // Initialize Mapbox map with custom style
        const map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/newisland1223/clzig8nrs00l501qqa3yxfgzm',
            center: [114.00, 22.45], // Centered on Tin Shui Wai
            zoom: 12
        });

        // Define isochrone time intervals and colors
        const intervals = [5, 10, 15]; // Minutes
        const colors = ['#FFEDA0', '#FEB24C', '#E31A1C'];
        const layers = intervals.map((interval, idx) => ({
            id: `isochrone-${interval}`,
            source: `isochrone-${interval}`,
            color: colors[idx],
            visible: true
        }));

        // Embedded CSV data
        const csvData = await fetch('CSDI_Leisure_with_Descriptions_by_New_Town.csv').then(r => r.text());

        map.on('load', () => {
            // Parse CSV data
            Papa.parse(csvData, {
                header: true,
                skipEmptyLines: true,
                transformHeader: header => header.trim().replace(/^"|"$/g, ''),
                transform: value => value.trim().replace(/^"|"$/g, ''),
                complete: async results => {
                    const facilities = results.data.filter(row => {
                        const lat = parseFloat(row.latitude);
                        const lon = parseFloat(row.longitude);
                        return !isNaN(lat) && !isNaN(lon) && lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180;
                    });

                    // Fetch isochrones with retry logic
                    const isochronePromises = facilities.map(facility => 
                        fetchIsochronesWithRetry(facility.latitude, facility.longitude, facility.name, 2)
                    );
                    const allIsochrones = await Promise.all(isochronePromises);

                    // Group and merge isochrones by interval into single polygons
                    const mergedIsochrones = intervals.reduce((acc, interval) => {
                        acc[interval] = [];
                        return acc;
                    }, {});

                    allIsochrones.forEach((isochrones, idx) => {
                        if (isochrones) {
                            isochrones.forEach((feature, i) => {
                                if (feature) mergedIsochrones[intervals[i]].push(feature);
                            });
                        } else {
                            console.warn(`No isochrones returned for ${facilities[idx].name}`);
                        }
                    });

                    // Merge all isochrones for each interval into a single contiguous polygon
                    intervals.forEach((interval, idx) => {
                        let merged = null;
                        mergedIsochrones[interval].forEach((feature, i) => {
                            if (i === 0) {
                                merged = feature;
                            } else {
                                try {
                                    // Use turf.union to combine into a single polygon, ensuring contiguous boundaries
                                    merged = turf.union(merged, feature);
                                } catch (e) {
                                    console.warn(`Union failed for interval ${interval} minutes at ${feature.properties.name}:`, e);
                                }
                            }
                        });

                        if (merged) {
                            map.addSource(`isochrone-${interval}`, {
                                type: 'geojson',
                                data: merged
                            });
                            map.addLayer({
                                id: `isochrone-${interval}`,
                                type: 'fill',
                                source: `isochrone-${interval}`,
                                paint: {
                                    'fill-color': colors[idx],
                                    'fill-opacity': 0.4,
                                    'fill-outline-color': colors[idx]
                                }
                            });
                            map.on('click', `isochrone-${interval}`, e => {
                                new mapboxgl.Popup()
                                    .setLngLat(e.lngLat)
                                    .setHTML(`Walkable in ${interval} minutes`)
                                    .addTo(map);
                            });
                        }
                    });

                    // Add facility markers
                    const markers = {
                        type: 'FeatureCollection',
                        features: facilities.map(facility => ({
                            type: 'Feature',
                            geometry: {
                                type: 'Point',
                                coordinates: [parseFloat(facility.longitude), parseFloat(facility.latitude)]
                            },
                            properties: {
                                name: facility.name
                            }
                        }))
                    };

                    map.addSource('facilities', {
                        type: 'geojson',
                        data: markers
                    });
                    map.addLayer({
                        id: 'facilities',
                        type: 'circle',
                        source: 'facilities',
                        paint: {
                            'circle-radius': 6,
                            'circle-color': '#007cbf'
                        }
                    });

                    map.on('click', 'facilities', e => {
                        const name = e.features[0].properties.name;
                        new mapboxgl.Popup()
                            .setLngLat(e.lngLat)
                            .setHTML(name)
                            .addTo(map);
                    });
                    map.on('mouseenter', 'facilities', () => map.getCanvas().style.cursor = 'pointer');
                    map.on('mouseleave', 'facilities', () => map.getCanvas().style.cursor = '');

                    // Add layer control with event listeners attached during creation
                    const layerControl = document.createElement('div');
                    layerControl.className = 'mapboxgl-ctrl mapboxgl-ctrl-group';
                    intervals.forEach((interval, idx) => {
                        const div = document.createElement('div');
                        div.style.padding = '5px';
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.id = `layer-${interval}`;
                        checkbox.checked = true;
                        const label = document.createElement('label');
                        label.htmlFor = `layer-${interval}`;
                        label.textContent = ` ${interval} min`;
                        div.appendChild(checkbox);
                        div.appendChild(label);
                        layerControl.appendChild(div);

                        // Attach event listener immediately after creating the checkbox
                        checkbox.addEventListener('change', e => {
                            map.setLayoutProperty(`isochrone-${interval}`, 'visibility', e.target.checked ? 'visible' : 'none');
                        });
                    });
                    map.getContainer().appendChild(layerControl);

                    // Add legend
                    const legend = document.createElement('div');
                    legend.className = 'legend';
                    intervals.forEach((interval, idx) => {
                        legend.innerHTML += `<div><span class="legend-color" style="background:${colors[idx]}"></span>${interval} minutes</div>`;
                    });
                    map.getContainer().appendChild(legend);
                },
                error: err => console.error('CSV parsing error:', err)
            });
        });

        // Fetch isochrones with retry
        async function fetchIsochronesWithRetry(lat, lon, name, maxRetries = 2) {
            const url = `https://api.mapbox.com/isochrone/v1/mapbox/walking/${lon},${lat}?contours_minutes=${intervals.join(',')}&polygons=true&access_token=${mapboxgl.accessToken}`;
            
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    const data = await response.json();
                    return data.features.map(feature => {
                        feature.properties.name = name;
                        return feature;
                    });
                } catch (error) {
                    console.warn(`Attempt ${attempt} failed for ${name}:`, error.message);
                    if (attempt === maxRetries) {
                        console.error(`Failed to fetch isochrones for ${name} after ${maxRetries} attempts:`, error);
                        return null;
                    }
                    await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1s before retry
                }
            }
        }
    </script>
</body>
</html>
